/*
 * Copyright (C) 2018 Amlogic Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "aml_channel_map"


#include <unistd.h>
#include "aml_channel_map.h"
#include "log.h"
#include "aml_audio_log.h"
#include "aml_config_parser.h"


#define MAX_CHANNELS "MAX_CHANNELS"
#define CHANNEL_MAP "CH_MAP"
#define ORDER_TYPE  "order_type"
#define SRC_CHS     "src_ch"
#define MAPPING     "mapping"
#define SRC_ORDER   "src_order"
#define DST_ORDER   "dst_order"
#define SCALE       "scale"
#define SPEAKER_SETTING "Speaker_Setting"




struct ch_present {
    char ch_name[64];
    channel_id_t ch_id;
    int  present;
    int  order;
};

typedef struct channel_map_item {
    int src_order;
    int dst_order;
    float scale;
} channel_map_item_t;


typedef struct channel_order {
    channel_order_type_t order_type;
    int ch;
    int ch_layout;  /*not used*/
    int chmap_item_cnt;
    channel_map_item_t *ch_map_items;
} channel_order_t;

/*these table will be generated by config file*/
static  channel_map_item_t hdmi_pcm8ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 3 , 1.0},
    {3, 2 , 1.0},
    {4, 4 , 1.0},
    {5, 5 , 1.0},
    {6, 6 , 1.0},
    {7, 7 , 1.0},
};

static  channel_map_item_t hdmi_pcm8ch_map_4ch[] = {
    {0, 0 , 0.5},
    {1, 1 , 0.5},
    {2, 3 , 1.0},
    {3, 2 , 1.0},
    {4, 0 , 0.25},
    {5, 1 , 0.25},
    {6, 0 , 0.25},
    {7, 1 , 0.25},
};

static  channel_map_item_t hdmi_pcm8ch_map_2ch[] = {
    {0, 0 , 0.25},
    {1, 1 , 0.25},
    {2, 3 , 0},
    {3, 0 , 0.25},
    {3, 1 , 0.25},
    {4, 0 , 0.25},
    {5, 1 , 0.25},
    {6, 0 , 0.25},
    {7, 1 , 0.25},
};


static  channel_map_item_t hdmi_pcm2ch_map_8ch[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {0, 3 , 0},
    {1, 3 , 0},
    {0, 2 , 0.5},
    {1, 2 , 0.5},
    {0, 4 , 1.0},
    {1, 5 , 1.0},
    {0, 6 , 1.0},
    {1, 7 , 1.0},
};

static  channel_map_item_t hdmi_pcm2ch_map_4ch[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {0, 2 , 0.5},
    {1, 2 , 0.5},
    {1, 3 , 0},
};


static  channel_map_item_t hdmi_pcm2ch_map_2ch[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
};



static  channel_map_item_t hdmi_dolby2ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
};

static  channel_map_item_t hdmi_dolby4ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 2 , 1.0},
    {3, 3 , 1.0},
};

static  channel_map_item_t hdmi_dolby8ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 2 , 1.0},
    {3, 3 , 1.0},
    {4, 4 , 1.0},
    {5, 5 , 1.0},
    {6, 6 , 1.0},
    {7, 7 , 1.0},
};


static struct channel_order hdmi_pcm8ch = {
    .order_type = CHANNEL_ORDER_HDMIPCM,
    .ch = 8,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,
};

static struct channel_order hdmi_pcm2ch = {
    .order_type = CHANNEL_ORDER_HDMIPCM,
    .ch = 2,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

static struct channel_order dolby_2ch = {
    .order_type = CHANNEL_ORDER_DOLBY,
    .ch = 2,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

/*currently 8ch is 5.1.2*/
static struct channel_order dolby_8ch = {
    .order_type = CHANNEL_ORDER_DOLBY,
    .ch = 8,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

static struct channel_order dolby_4ch = {
    .order_type = CHANNEL_ORDER_DOLBY,
    .ch = 4,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

#define CH_ORDER_NUM    10
static int output_max_ch = 8;
static int channel_map_array_size = 0;
static struct channel_order * ch_map_array = NULL;

static struct channel_order ch_orders[CH_ORDER_NUM] = {
};

/*the string is same with Dolby*/
static struct ch_present ch_presents[] = {
    {"Left",  CHANNEL_LEFT_FRONT, 0},
    {"Right",  CHANNEL_RIGHT_FRONT, 0},
    {"Center",   CHANNEL_CENTER, 0},
    {"LFE", CHANNEL_LFE, 0},
    {"Left Surround", CHANNEL_LEFT_SURROUND, 0},
    {"Right Surround", CHANNEL_RIGHT_SURROUND, 0},
    {"Left Rear Surround", CHANNEL_LEFT_REAR_SURROUND, 0},
    {"Right Rear Surround", CHANNEL_RIGHT_REAR_SURROUND, 0},
    {"Left Top Front", CHANNEL_LEFT_TOP_FRONT, 0},
    {"Right Top Front", CHANNEL_RIGHT_TOP_FRONT, 0},
    {"Left Top Middle", CHANNEL_LEFT_TOP_MIDDLE, 0},
    {"Right Top Middle", CHANNEL_RIGHT_TOP_MIDDLE, 0},
    {"Left Top Rear", CHANNEL_LEFT_TOP_REAR, 0},
    {"Right Top Rear", CHANNEL_RIGHT_TOP_REAR, 0},
    {"Left Dolby Atmos",  CHANNEL_LEFT_DOLBY_ENABLE, 0},
    {"Right Dolby Atmos",  CHANNEL_RIGHT_DOLBY_ENABLE, 0},
    {"Left Surround Dolby Atmos",  CHANNEL_LEFT_SUR_DOLBY_ENABLE, 0},
    {"Right Surround Dolby Atmos",  CHANNEL_RIGHT_SUR_DOLBY_ENABLE, 0},
    {"Left Rear Surround Dolby Atmos",  CHANNEL_LEFT_REAR_SUR_DOLBY_ENABLE, 0},
    {"Right Rear Surround Dolby Atmos",  CHANNEL_RIGHT_SUR_DOLBY_ENABLE, 0},
};

static void set_channel_map_default(int ch)
{
    /*we need to replace these config with config file*/
    if (ch > 4) {
        hdmi_pcm8ch.chmap_item_cnt = sizeof(hdmi_pcm8ch_map) / sizeof(channel_map_item_t);
        hdmi_pcm8ch.ch_map_items = &hdmi_pcm8ch_map[0];
        ch_orders[0] = hdmi_pcm8ch;

        hdmi_pcm2ch.chmap_item_cnt = sizeof(hdmi_pcm2ch_map_8ch) / sizeof(channel_map_item_t);
        hdmi_pcm2ch.ch_map_items = &hdmi_pcm2ch_map_8ch[0];
        ch_orders[1] = hdmi_pcm2ch;


    } else if (ch > 2){
        hdmi_pcm8ch.chmap_item_cnt = sizeof(hdmi_pcm8ch_map_4ch) / sizeof(channel_map_item_t);
        hdmi_pcm8ch.ch_map_items = &hdmi_pcm8ch_map_4ch[0];
        ch_orders[0] = hdmi_pcm8ch;

        hdmi_pcm2ch.chmap_item_cnt = sizeof(hdmi_pcm2ch_map_4ch) / sizeof(channel_map_item_t);
        hdmi_pcm2ch.ch_map_items = &hdmi_pcm2ch_map_4ch[0];
        ch_orders[1] = hdmi_pcm2ch;
    } else {
        hdmi_pcm8ch.chmap_item_cnt = sizeof(hdmi_pcm8ch_map_2ch) / sizeof(channel_map_item_t);
        hdmi_pcm8ch.ch_map_items = &hdmi_pcm8ch_map_2ch[0];
        ch_orders[0] = hdmi_pcm8ch;

        hdmi_pcm2ch.chmap_item_cnt = sizeof(hdmi_pcm2ch_map_2ch) / sizeof(channel_map_item_t);
        hdmi_pcm2ch.ch_map_items = &hdmi_pcm2ch_map_2ch[0];
        ch_orders[1] = hdmi_pcm2ch;
    }


    dolby_2ch.chmap_item_cnt = sizeof(hdmi_dolby2ch_map) / sizeof(channel_map_item_t);
    dolby_2ch.ch_map_items = &hdmi_dolby2ch_map[0];
    ch_orders[2] = dolby_2ch;

    dolby_8ch.chmap_item_cnt = sizeof(hdmi_dolby8ch_map) / sizeof(channel_map_item_t);
    dolby_8ch.ch_map_items = &hdmi_dolby8ch_map[0];
    ch_orders[3] = dolby_8ch;

    dolby_4ch.chmap_item_cnt = sizeof(hdmi_dolby4ch_map) / sizeof(channel_map_item_t);
    dolby_4ch.ch_map_items = &hdmi_dolby4ch_map[0];
    ch_orders[4] = dolby_4ch;
}

static channel_order_t * get_channel_map(int ch, channel_order_type_t order_type)
{
    int i = 0;

    if (ch_map_array) {
        for (i = 0; i < channel_map_array_size ; i++) {
            if (ch_map_array[i].ch == ch && ch_map_array[i].order_type == order_type) {
                return &ch_map_array[i];
            }
        }
    }
#if 0
    for (i = 0; i < CH_ORDER_NUM ; i++) {
        if (ch_orders[i].ch == ch && ch_orders[i].order_type == order_type) {
            return &ch_orders[i];
        }
    }
#endif
    return NULL;
}

static void init_ch_presents(char * speaker_config)
{
    char * token = NULL;
    int item = 0;
    int i = 0;
    int ch_cnt = 0;
    char temp[256] = {0};

    if (speaker_config == NULL) {
        return;
    }

    memcpy(temp, speaker_config, strlen(speaker_config));
    item = sizeof(ch_presents) / sizeof(struct ch_present);
    token = strtok(temp, ":");

    for (i = 0; i < item; i++) {
        ch_presents[i].present = 0;
        ch_presents[i].order   = -1;
    }
    /*if there is no config, set all the presents on*/
    if (token == NULL) {
        for (i = 0; i < item; i++) {
            /*set default 2ch*/
            if (i < 2) {
                ch_presents[i].present = 1;
                ch_presents[i].order   = i;
            }
        }
    }
    while (token != NULL) {

        for (i = 0; i < item; i++) {
            if (!strcmp(ch_presents[i].ch_name, token)) {
                ch_presents[i].present = 1;
                ch_presents[i].order   = ch_cnt;
                ch_cnt++;
                ALOGD(" channel presents=%s id=%d order=%d\n", ch_presents[i].ch_name, ch_presents[i].ch_id, ch_presents[i].order);
            }
        }
        token = strtok(NULL, ":");

    }
    return;
}

static inline int get_speaker_ch_cnt(void)
{
    int item = 0;
    int i = 0;
    int ch_cnt = 0;
    item = sizeof(ch_presents) / sizeof(struct ch_present);

    for (i = 0; i < item; i++) {
        if (ch_presents[i].present) {
            ch_cnt++;
        }
    }
    return ch_cnt;
}


static void init_speaker_setting (cJSON *speaker_setting) {
    int i = 0;
    cJSON *temp;
    int item;

    item = sizeof(ch_presents) / sizeof(struct ch_present);

    for (i = 0; i < item; i++) {
        ch_presents[i].present = 0;
        ch_presents[i].order   = -1;
    }

    for (i = 0 ; i < item; i++) {
        temp = cJSON_GetObjectItem(speaker_setting, ch_presents[i].ch_name);
        if (temp == NULL) {
            ALOGD("%s is NULL\n", ch_presents[i].ch_name);
            continue;
        }

        ch_presents[i].order = temp->valueint;
        if (ch_presents[i].order != -1) {
            ch_presents[i].present = 1;
        } else {
            ch_presents[i].present = 0;
        }
        ALOGD(" channel presents=%s id=%d order=%d\n", ch_presents[i].ch_name, ch_presents[i].ch_id, ch_presents[i].order);

    }
}

static channel_order_t * parse_channel_map(cJSON *ch_map_config)
{
    int i = 0;
    int item_cnt = 0;
    channel_order_t * channel_orders = NULL;
    cJSON * ch_map = NULL;
    cJSON *temp = NULL;
    cJSON *mapping = NULL;
    item_cnt = cJSON_GetArraySize(ch_map_config);
    if (item_cnt == 0) {
        return NULL;
    }
    channel_orders = (channel_order_t *)calloc(1, item_cnt * sizeof(channel_order_t));
    for (i = 0; i < item_cnt; i++) {
        int mapping_item = 0;
        int j = 0;
        channel_map_item_t * map_item = NULL;
        ch_map = cJSON_GetArrayItem(ch_map_config, i);
        temp = cJSON_GetObjectItem(ch_map, ORDER_TYPE);
        if (temp) {
            channel_orders[i].order_type = temp->valueint;
        }

        temp = cJSON_GetObjectItem(ch_map, SRC_CHS);
        if (temp) {
            channel_orders[i].ch = temp->valueint;
        }
        mapping = cJSON_GetObjectItem(ch_map, MAPPING);
        mapping_item = cJSON_GetArraySize(mapping);
        if (mapping_item == 0) {
            continue;
        }
        map_item = calloc(1 , mapping_item * sizeof(channel_map_item_t));
        channel_orders[i].chmap_item_cnt = mapping_item;
        channel_orders[i].ch_map_items   = map_item;
        //printf("order=%d ch=%d map_item=%d\n", channel_orders[i].order_type, channel_orders[i].ch, channel_orders[i].chmap_item_cnt);
        for (j = 0; j < mapping_item; j++) {
            ch_map = cJSON_GetArrayItem(mapping, j);
            temp = cJSON_GetObjectItem(ch_map, SRC_ORDER);
            if (temp) {
                map_item[j].src_order = temp->valueint;
            }

            temp = cJSON_GetObjectItem(ch_map, DST_ORDER);
            if (temp) {
                map_item[j].dst_order = temp->valueint;
            }

            temp = cJSON_GetObjectItem(ch_map, SCALE);
            if (temp) {
                map_item[j].scale = (float)temp->valuedouble;
            }
            //printf("map (%d)->%d scale=%f\n", map_item[j].src_order, map_item[j].dst_order, map_item[j].scale);

        }
    }
    return channel_orders;
}


int aml_channelinfo_init(channel_info_t * channel_info)
{
    int i = 0, j = 0;
    int item = 0;
    item = sizeof(ch_presents) / sizeof(struct ch_present);
    for (i = 0; i < AML_MAX_CHANNELS; i++) {
        channel_info->channel_items[i].ch_id = -1;
        channel_info->channel_items[i].present = 0;
        channel_info->channel_items[i].order = -1;

        for (j = 0; j < item; j++) {
            if (i == ch_presents[j].order) {
                channel_info->channel_items[i].ch_id   = ch_presents[j].ch_id;
                channel_info->channel_items[i].present = ch_presents[j].present;
                channel_info->channel_items[i].order   = ch_presents[j].order;
            }
        }
    }
    return 0;
}

void aml_channelmap_dumpinfo(void * private)
{
    aml_channel_map_t * handle = (aml_channel_map_t *)private;
    channel_order_t *channel_order = NULL;
    int ch_map_cnt = 0;
    int src_order = 0;
    int dst_order = 0;
    float sacling = 1.0;
    int i = 0;

    channel_order = (channel_order_t *)handle->map_info;
    if (channel_order) {
        ch_map_cnt = channel_order->chmap_item_cnt;
        ALOGA("order type=%d ch=%d\n", channel_order->order_type, channel_order->ch);
        for (i = 0; i < ch_map_cnt; i++) {
            ALOGA("map (%d)->%d scale=%f\n", channel_order->ch_map_items[i].src_order, channel_order->ch_map_items[i].dst_order, channel_order->ch_map_items[i].scale);
        }
    }

    return;
}

void aml_channelmap_parser_init(void * json_config) {
    cJSON *temp = NULL;
    int map_item_cnt = 0;
    if (json_config) {
        //printf_cJSON("json_config", json_config);

        temp = cJSON_GetObjectItem((cJSON *)json_config, MAX_CHANNELS);
        aml_printf_cJSON("max channel", temp);
        if (temp) {
            output_max_ch = temp->valueint;
        }

        temp = cJSON_GetObjectItem((cJSON *)json_config, SPEAKER_SETTING);
        if (temp) {
            init_speaker_setting(temp);
        }


        temp = cJSON_GetObjectItem((cJSON *)json_config, CHANNEL_MAP);
        if (temp) {
            channel_map_array_size = cJSON_GetArraySize(temp);
            ch_map_array = parse_channel_map(temp);
        }

    }

}
void aml_channelmap_parser_deinit( ) {
    int i = 0;
    if (ch_map_array) {
        for (i = 0; i < channel_map_array_size; i++) {
            if (ch_map_array[i].ch_map_items != NULL) {
                free(ch_map_array[i].ch_map_items);
                ch_map_array[i].ch_map_items = NULL;
            }
        }
        free(ch_map_array);
        ch_map_array = NULL;
    }
}


int aml_channelmap_init(aml_channel_map_t ** handle, char * speaker_config)
{
    int ret = -1;
    int i = 0;
    int size = 1024 * 4;
    void *tmp_map_buffer;
    aml_channel_map_t * channel_map = NULL;
    aml_data_format_t * format = NULL;
    int max_ch = output_max_ch;

    ALOGD("MAP INIT\n");

    channel_map = calloc(1 , sizeof(aml_channel_map_t));

    if (channel_map == NULL) {
        ALOGD("channel_map malloc failed\n");
        goto exit;
    }

    tmp_map_buffer = calloc(1 , size);
    if (tmp_map_buffer == NULL) {
        ALOGD("tmp_map_buffer malloc failed\n");
        goto exit;

    }

    channel_map->map_buffer = tmp_map_buffer;
    channel_map->map_buffer_size = size;

    format = &channel_map->format;

    format->ch = max_ch;

    /*get the speaker config */
    //init_ch_presents(speaker_config);

    /*this speaker ch is different with the input ch*/
    set_channel_map_default(get_speaker_ch_cnt());

    /*according the speaker config to set the channel info*/
    aml_channelinfo_init(&channel_map->format.channel_info);


    *handle = channel_map;

    aml_log_dumpinfo_install(LOG_TAG, aml_channelmap_dumpinfo, channel_map);

    return 0;
exit:
    if (channel_map) {
        free(channel_map);
    }
    if (tmp_map_buffer) {
        free(tmp_map_buffer);
    }
    return -1;

}

int aml_channelmap_close(aml_channel_map_t * handle)
{
    if (handle == NULL) {
        return 0;
    }

    aml_log_dumpinfo_remove(LOG_TAG);

    if (handle->map_buffer) {
        free(handle->map_buffer);
        handle->map_buffer = NULL;
    }

    free(handle);

    return 0;
}

int aml_channelmap_process(aml_channel_map_t * handle, aml_data_format_t *src, void * in_data, size_t nframes)
{
    int i = 0, j = 0;
    int dst_channels = 0;
    int src_channels = 0;
    aml_data_format_t * dst = NULL;
    channel_order_t *channel_order = NULL;
    int ch_map_cnt = 0;
    int src_order = 0;
    int dst_order = 0;
    float sacling = 1.0;

    size_t need_bytes = 0;
    dst = &handle->format;
    dst->bitwidth = src->bitwidth;
    dst->format   = src->format;
    dst->sr       = src->sr;
    dst->ch_order_type = src->ch_order_type;

    channel_order = get_channel_map(src->ch, src->ch_order_type);
    handle->map_info = (void*)channel_order;

    if (channel_order == NULL) {
        /*we don't find the channel map info, just copy the data*/
        need_bytes = nframes * (src->bitwidth >> 3) * src->ch;

    } else {
        need_bytes = nframes * (dst->bitwidth >> 3) * dst->ch;
    }

    if (handle->map_buffer_size < need_bytes) {
        ALOGI("realloc map_buffer_size  from %zu to %zu\n", handle->map_buffer_size, need_bytes);
        handle->map_buffer = realloc(handle->map_buffer, need_bytes);
        if (handle->map_buffer == NULL) {
            ALOGE("realloc map_buffer failed size %zu\n", need_bytes);
            return -1;
        }
        handle->map_buffer_size = need_bytes;
        memset(handle->map_buffer, 0, need_bytes);

    }
    memset(handle->map_buffer, 0, need_bytes);
    handle->out_buffer_size = need_bytes;

    if (channel_order) {
        ch_map_cnt = channel_order->chmap_item_cnt;
        //ALOGD("channel map cnt=%d src ch=%d type=%d\n",ch_map_cnt,src->ch, src->ch_order_type);
        for (i = 0; i < ch_map_cnt; i++) {
            switch (src->bitwidth) {
            case SAMPLE_8BITS:
                // not support
                break;
            case SAMPLE_16BITS: {
                short * src_data = (short *)in_data;
                short * dst_data = (short *)handle->map_buffer;
                int src_channel  = src->ch;
                int dst_channel  = dst->ch;
                dst_order = channel_order->ch_map_items[i].dst_order;
                src_order = channel_order->ch_map_items[i].src_order;
                sacling   = channel_order->ch_map_items[i].scale;
                if (src_order >= src_channel || dst_order >= dst_channel) {
                    ALOGE("wrong mapping[%d %d]->[%d %d]\n",src_order,src_channel,dst_order,dst_channel);
                    continue;
                }
                for (j = 0; j < nframes; j ++) {
                    dst_data[j * dst_channel + dst_order] += src_data[j * src_channel + src_order] * sacling;

                }
            }
            break;
            case SAMPLE_24BITS:
                // not suppport
                break;
            case SAMPLE_32BITS: {
                int * src_data = (int *)in_data;
                int * dst_data = (int *)handle->map_buffer;
                int src_channel  = src->ch;
                int dst_channel  = dst->ch;
                dst_order = channel_order->ch_map_items[i].dst_order;
                src_order = channel_order->ch_map_items[i].src_order;
                sacling   = channel_order->ch_map_items[i].scale;
                if (src_order >= src_channel || dst_order >= dst_channel) {
                    ALOGE("wrong mapping[%d %d]->[%d %d]\n",src_order,src_channel,dst_order,dst_channel);
                    continue;
                }
                for (j = 0; j < nframes; j ++) {
                    dst_data[j * dst_channel + dst_order] += src_data[j * src_channel + src_order] * sacling;

                }
            }
            break;
            default:
                break;
            }
        }
    }else {
        memcpy(handle->map_buffer, in_data, need_bytes);
        handle->out_buffer_size = need_bytes;
        dst->ch = src->ch;
    }

    memcpy(&src->channel_info, &dst->channel_info, sizeof(channel_info_t));

    return 0 ;
}
